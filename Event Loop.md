## Event Loop

## 同步和异步

### 一. 正常情况下，浏览器是单线程的

JavaScript最大的特点是单线程，当Javascript要操作Dom的时候，就不会出现两个线程同时操作Dom的情况了。

### 二. 同步和异步
    
所以如果全部代码都是同步执行的，这会引发很严重的问题，比方说我们要从远端获取一些数据，难道要一直
循环代码去判断是否拿到了返回结果么？就像去饭店点餐，肯定不能说点完了以后就去后厨催着人炒菜的，会被揍的。

于是就有了异步事件的概念，注册一个回调函数，比如说发一个网络请求，我们告诉主程序等到接收到数据后
通知我，然后我们就可以去做其他的事情了。

然后在异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁
等待，等到程序空闲下来才有时间去看哪些异步已经完成了，可以去执行。

#### 常见的异步方法

1. setTimeout、setInterval

2. 事件监听

采用事件驱动模式。

监听函数有：on，bind，listen，addEventListener，observe。

3. promise

4. async/await

5. 网络请求

等等。

#### 浏览器的线程

一个浏览器进程通常由以下五个线程组成：

1. GUI渲染线程。

GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,
该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了。

2. JavaScript引擎线程。

Javascript引擎，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎
线程负责解析Javascript脚本，运行代码。

3. 事件触发线程。

当一个事件被触发时该线程会把事件添加到待处理事件队列的队尾，等待JS引擎的处理。这些事件可以是当前执行
的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系
所有这些事件都得排队等待JS引擎处理。

4. 定时器线程。

浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的,如果处于阻塞线程状态
就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

5. 异步HTTP请求线程。

### 三. Web Worker

HTML5 中提出 Web Worker 标准，允许新开一个线程，但是新开子线程受主线程控制，并且不能操作DOM。
    
## 任务队列

### 1. 主线程

所有同步任务都在主线程上执行，形成一个执行栈

### 2. 任务队列

主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置
一个事件。

### 3. 执行栈执行完毕

一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，
于是结束等待状态，进入执行栈，开始执行。

### 4. 只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。

## Event Loop

同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的
任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 
Event Loop (事件循环)。

### 异步的任务执行为什么也分前后？

task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 
都要执行所有的微任务。

## 总结

最后的最后，记住，JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，
并没有专门的异步执行线程。


