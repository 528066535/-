## 从URL输入到页面展现到底发生什么？

### 1.域名解析

DNS 协议提供通过域名查找 IP 地址。

过程是

检查浏览器缓存=>检查系统缓存=>检查本地host文件是否有缓存=>再检查路由器=>检查服务商=>根服务器

#### 前端如果做

a. host 文件修改域名 ip对应关系，可做到本地调试。

b. CDN. CDN会在请求到数据后，把数据缓存在CDN节点上，并且利用NDS的这种重定向的功能，返回最近节点资源，也缓解了服务器的压力。

c. dns-prefetch DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。经观察，DNS预解析过程大致可减少 20~200ms的时间。

用法： <link rel="dns-prefetch" href="xxx">

注：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。

### 2.建立TCP连接

TCP 三次握手

### 3.HTTP请求

HTTP版本有 1.0 ， 1.1 ， 2.0 版本，目前 1.1 版本使用最广泛。

#### 缓存相关 header

缓存可以达到快速拿到资源的目的，减少请求时间，而我们知道，缓存一般都是针对静态资源，比如js，css，图片等等。

Expires:响应头，代表该资源的过期时间。

Cache-Control:请求/响应头，缓存控制字段，精确控制缓存策略。（强制缓存）

Cache-Control 除了可以设置 max-age 相对过期时间以外，还可以设置成如下几种值：
public，资源允许被中间服务器缓存。
private，资源不允许被中间代理服务器缓存。
no-cache，浏览器不做缓存检查。
no-store，浏览器和中间代理服务器都不能缓存资源。
must-revalidate，可以缓存，但是使用之前必须先向源服务器确认。
proxy-revalidate，要求缓存服务器针对缓存资源向源服务器进行确认。
s-maxage：缓存服务器对资源缓存的最大时间。

If-Modified-Since:请求头，资源最近修改时间，由浏览器告诉服务器。

Last-Modified:响应头，资源最近修改时间，由服务器告诉浏览器。

Etag:响应头，资源标识，由服务器告诉浏览器。

If-None-Match:请求头，缓存资源标识，由浏览器告诉服务器。

##### 原始模型

浏览器请求静态资源 a.js。（请求头：1KB）
服务器读取磁盘文件 a.js，返给浏览器。（10KB（a.js）+1KB（响应头） = 11KB）。
浏览器再次请求，服务器又重新读取磁盘文件 a.js，返给浏览器。
如此循环。。

##### 浏览器增加缓存机制

浏览器请求 a.js。
浏览器第一次请求 a.js，缓存 a.js 到本地磁盘。（1+10+1 =12KB）
浏览器再次请求 a.js，直接走浏览器缓存（200，from cache），不再向服务器发起请求。（0KB）

##### 服务器和浏览器约定资源过期时间

服务器和浏览器约定文件过期时间，用 Expires 字段来控制，时间是 GMT 格式的标准时间，如 Fri, 01 Jan 1990 00:00:00 GMT。

浏览器第一次请求一个静态资源 a.js。（1KB）
服务器把 a.js 和 a.js 的缓存过期时间(Expires：Mon, 26 Sep 2018 05:00:00 GMT)发给浏览器。（10+1=11KB）
浏览器接收到 a.js，同时记住了过期时间。
在2018年9月26日5点之前，浏览器再次请求 a.js，便不再请求服务器，直接使用上一次缓存的 a.js 文件。（0KB）
在2018年9月26日5点01分，浏览器请求 a.js，发现 a.js 缓存时间过了，于是不再使用本地缓存，而是请求服务器，服务器又重新读取磁盘文件 a.js，返给浏览器，同时告诉浏览器一个新的过期时间。（1+10+1=12KB）。

缺点还是有：
缓存过期以后，服务器不管 a.js有没有变化，都会再次读取 a.js文件，并返给浏览器。

##### 服务器告诉浏览器资源上次修改时间

为了解决上个方案的问题，服务器和浏览器经过磋商，制定了一种方案，服务器每次返回 a.js 的时候，还要告诉浏览器 a.js 在服务器上的最近修改时间 Last-Modified （GMT标准格式）。

浏览器访问 a.js 文件。（1KB）

服务器返回 a.js 的时候，告诉浏览器 a.js 文件。（10+1=11KB） 在服务器的上次修改时间 Last-Modified（GMT标准格式）以及缓存过期时间 Expires（GMT标准格式）

当 a.js 过期时，浏览器带上 If-Modified-Since（等于上一次请求的Last-Modified） 请求服务器。（1KB）

服务器比较请求头里的 Last-Modified 时间和服务器上 a.js 的上次修改时间：

1.如果一致，则告诉浏览器：你可以继续用本地缓存（304）。此时，服务器不再返回 a.js 文件。（1KB）

2.如果不一致，服务器读取磁盘上的 a.js 文件返给浏览器，同时告诉浏览器 a.js 的最近的修改时间 Last-Modified 以及过期时间 Expires。（1+10=11KB）

##### 继续改进，增加相对时间的控制，引入 Cache-Contorl

为了兼容已经实现了上述方案的浏览器，同时加入新的缓存方案，服务器除了告诉浏览器 Expires ，同时告诉浏览器一个相对时间 Cache-Control：max-age=10秒。意思是在10秒以内，使用缓存到浏览器的 a.js 资源。
浏览器先检查 Cache-Control，如果有，则以 Cache-Control 为准，忽略 Expires。如果没有 Cache-Control，则以 Expires 为准。

##### 继续改进，增加文件内容对比，引入Etag

为了解决文件修改时间只能精确到秒带来的问题，我们给服务器引入 Etag 响应头，a.js 内容变了，Etag 才变。内容不变，Etag 不变，可以理解为 Etag 是文件内容的唯一 ID。
同时引入对应的请求头 If-None-Match，每次浏览器请求服务器的时候，都带上If-None-Match字段，该字段的值就是上次请求 a.js 时，服务器返回给浏览器的 Etag。

浏览器请求 a.js。

服务器返回 a.js，同时告诉浏览器过期绝对时间（Expires）以及相对时间（Cache-Control：max-age=10），以及a.js上次修改时间Last-Modified，以及 a.js 的Etag。

10秒内浏览器再次请求 a.js，不再请求服务器，直接使用本地缓存。

11秒时，浏览器再次请求 a.js，请求服务器，带上上次修改时间 If-Modified-Since 和上次的 Etag 值 If-None-Match。

服务器收到浏览器的If-Modified-Since和Etag，发现有If-None-Match，则比较 If-None-Match 和 a.js 的 Etag 值，忽略If-Modified-Since的比较。

a.js 文件内容没变化，则Etag和If-None-Match 一致，服务器告诉浏览器继续使用本地缓存（304）。

##### 增加版本号

另外，不管用 Expires 还是 Cache-Control，他们都只能够控制缓存是否过期，但是在缓存过期之前，浏览器是无法得知服务器上的资源是否变化的。只有当缓存过期后，浏览器才会发请求询问服务器。所以需要在资源上增加版本号，让浏览器在 Cache-Control 起作用的情况下请求新的资源。

#### HTTP1.0 、 HTTP1.1 和 HTTP2.0 的区别

HTTP1.1 和 HTTP1.0 的最大区别是 HTTP1.1 默认开启 Connection: keep-alive。

1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求，不需要等待返回后再发送请求。这样就进一步改进了HTTP协议的效率。但是默认浏览器是关闭了这项功能。

原因是一些代理服务器不能正确的处理 HTTP Pipelining 和 由于服务器会一个一个按顺序返回浏览器的请求，所以前面的请求就大概率会阻塞后面的请求。

HTTP2.0和HTTP1.X相比的新特性

新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

服务端推送（server push）。

#### 优化

由于 http 请求的特性，所以我们打包的 js 和 css 如果能尽量的合并在一起，并且尽量高的命中缓存，那么请求时间会大大缩短。

另外也可以采用按需加载的方式，当界面需要显示的时候再去加载对应的界面，达到优化效果。


